---
layout: post
title: "机器学习: 12个提示"
date: 2018-12-26 21:28:00 +0800
categories: 机器学习
mathjax: true
figure: /images/2018-12/MLTips-1.jpg
author: Jarvis
meta: Post
---

* content
{:toc}

> 机器学习从数据中自动学习规则/函数/对应关系. 随着可获取数据量的不断增多, 机器学习的算法也层出不穷并广泛地应用在实践中. 但是机器学习种类繁多, 技巧不容易掌握, 因此也给其应用带来了不少的麻烦. 因此本文 [A Few Useful Things to Know about Machine Learning](https://dl.acm.org/citation.cfm?id=2347755) 总结了12个机器学习中常见的问题并加以探讨.




<div class="polaroid">
    <img class="cool-img" src="/images/2018-12/MLTips-1.jpg" MLTips/>
    <div class="container">
        <p>Machine Learning</p>
    </div>
</div>

## 1. 学习 = 表示 + 评估 + 优化

当我们遇到一个任务(假设是分类任务), 想要用机器学习的方法解决时发现有几千种算法, 那么该如何选择? 一种学习的算法一般包含三部分

* **表示(Representation)**: 要想用机器学习, 那么首先要把数据用某种方式表示出来, 这样学习器才能按照"学到的知识"根据这些数据的这种表示进行分类. 这种表示在机器学习中也称为**特征**. 当然, 选择不同的表示方式, 学习出来的模型也将不同, 我们称所有的表示方式为**假设空间**.
* **评估(Evaluation)**: 指评估函数(也成为损失函数), 用于评价学习器给出的预测结果好不好. 实际的学习过程中我们可能使用与最终标准不同的评估函数, 这是对算法缺陷的一种妥协.
* **优化(Optimization)**: 指优化算法, 用于搜索表现最好的学习器的算法. 算法种类很多, 通常入门者喜欢使用现成的(off-the-shelf)优化器, 熟练之后会逐渐改用自定义(custom-designed)的优化器.

下表列举了学习算法中常见的一些概念:

| 类型 | 举例 |
|:----:|:----|
| 表示 | 基于实例的: K-近邻, 支持向量机<br>基于超平面的: 朴素贝叶斯, 逻辑回归<br>决策树<br>基于规则的方法<br>神经网络<br>图模型: 贝叶斯网络, 条件随机场 |
| 评估 | 准确率/错误率: Accuracy/Error rate<br>精确率/召回率: Precision/Recall<br>平方误差: Squared error<br>似然: Likelihood<br>后验概率: Posterior probability<br>信息增益: Information gain<br>KL散度: K-L divergence<br>Cost/Utility<br>Margin |
| 优化 | 组合优化: 贪婪搜索, 定向搜索, 分支定界法<br>连续优化(无约束方法): 梯度下降, 共轭梯度, Quasi-Newton法<br>连续优化(约束方法): 线性规划, 二次规划 |

## 2. 重要的是泛化

机器学习的基本目标是让模型能够**泛化**到训练集以外的数据上. 而泛化的前提一定是我们无法让模型*见到*假设空间中所有的数据(因为所有的数据太多了), 因而只能从*小部分*数据中学习, 在*大部分*数据上实践.

让模型在用于训练的数据集上表现好是容易做到的, 只需要让模型简单地*记住*所有的数据即可, 但这样的模型在遇到新数据时就会不知所措. 因此在模型学习完毕后, <span class="tooltip">评估模型
<span class="tooltiptext">此处的评估非上一节提到的评估, 上一节是模型训练过程中的评估, 此处的评估是模型训练结束后在测试集上的评估</span>
</span>的好坏时需要用额外的数据集(独立于训练集的一个数据集, 一般称为测试集)进行测试.

但是单纯的从数据集中留出一部分作为测试集又有可能因为留出的部分不均匀而造成结果的不准确, 因此常用**交叉验证**避免这样的麻烦. 即把数据集均匀地划分为 $$ k $$ 份, 每次用其中的 $$ k-1 $$ 份训练模型, 剩余的 $$ 1 $$ 份测试, 最后把训练的 $$ k $$ 个模型结果的平均值作为最后的结果.

## 3. 只有数据是不够的

以泛化作为目标导致的结果就是: 只有数据是不够的. 想象一下我们有百万数据集(看起来很大了), 但是如果我们要学习一个包含100个布尔变量(只取 $$ \{0, 1\} $$)的函数, 那么实际上我们的模型还有 $$ 2^100-10^6 $$ 个数据样本是没见过的, 如何让模型也能正确的预测这些数据的类别? 

**没有免费的午餐定理(No Free Lunch, NFL)**就告诉我们这么一件事, 纯粹研究一个算法是没有意义的, 因为没有一个算法能够比其他算法更高效, 某个算法在某些问题上高效, 就必然会在其他某些问题上低效. 当然这个定理并非为了打击研究人员的信心, 而是告诉人们研究算法必须落实在具体的问题上, 针对某个(些)问题或在一定的假设下改进算法才是有意义的.

比如,
* 当你知道许多样本相似性的信息时, 基于实例的方法是好的选择
* 当你知道许多概率依赖的信息时, 图模型是好的选择
* 当你知道每个类别需要什么预设条件时, 基于规则的方法是更好的选择
* ......

## 4. 过拟合的多面性

当一个学习器在训练集上达到了100%的准确率, 而在测试集上仅有50%的准确率, 那么这个学习器就陷入了**过拟合**的困境. 

一种理解过拟合的方法是把泛化误差分解为偏差(bias)和方差(variance). 偏差和方差的含义下图可以清楚的表现:

<div class="polaroid-tiny">
    <img class="cool-img" src="/images/2018-12/MLTips-2.jpg" MLTips/>
    <div class="container">
        <p>Bias and variance in dart-throwing.</p>
    </div>
</div>

下图是在包含64个布尔值特征的样本上训练的两个分类器, 样本的真实类别由"if...then..."规则给出. 从图中可以看出即使有1000个样本, 贝叶斯方法也要比规则学习器好, 尽管朴素贝叶斯学习器的<span class="tooltip">线性边界
<span class="tooltiptext">类条件概率分布为指数分布族时朴素贝叶斯分类器是线性分类器<sup>1</sup></span>
</span>假设对于该数据集是错误的. 

<div class="polaroid-script">
    <img class="cool-img" src="/images/2018-12/MLTips-3.jpg" MLTips/>
    <div class="container">
        <p>Naive Bayes can outperform C4.5rules.</p>
    </div>
</div>

总结下来就是: 强的错误假设也可能要比弱的正确假设更好, 因为使用后者的学习器需要更多的数据来避免过拟合.

有很多方法减弱模型的过拟合问题, 最受欢迎的是在损失函数中加一个**正则项**来抑制模型的过度学习. 

要注意的是, 过拟合并不全是因为数据集中的*噪声*引起的. 噪声(即数据集中错误的数据点)的确会给模型带来过拟合的风险, 但是如果训练集和测试集中数据的分布不均匀(比如训练集中只有 `true` 的类别, 测试集中只有 `false` 的类别), 那么即使没有任何噪声模型也会过拟合. 因此数据集的**均匀性**也是重要的.

## 5. 我们的直观在高维上失效

人类仅能想象到最高三维空间, 而在数据空间中特征维度远超人类的想象, 高维数据也是机器学习中的一个巨大的问题, 称为**维度灾难**. 随着数据维度的升高, 我们能获取的数据集占整个数据空间的比例以指数下降. 比如一个普通的100维数据, 即使有trillion(万亿)规模的数据集, 也仅占整个数据空间的$$ 10^{-18} $$, 也就是说数据在空间中的分布是极其稀疏的, 而实际上对于分类等任务来说其中部分维度是有用的, 其他维度就变成了噪声, 这些给数据分类/聚类带来了不小的挑战.

幸运的是, 绝大部分数据集的数据点并非均匀的分布在整个数据空间中(blessing of non-uniformly), 而是嵌在某个低维[流形](https://en.wikipedia.org/wiki/Manifold)上. 比如手写数字数据集, 假设每个数字都是一张$$ 28\times 28 $$的图像, 那么数据空间是 $$ 784 $$ 维的, 但实际上目前的多种分类器都能够利用较少的维度即可实现高精度(>99%)的分类.

<div class="polaroid-script">
    <img class="cool-img" src="/images/2018-12/MLTips-4.png" MLTips/>
    <div class="container">
        <p>手写数字嵌入低维流形</p>
    </div>
</div>

## 6. 理论保证并没有看起来那么有用

机器学习的研究者在几十年来提多了许许多多的理论保证, 比如随着数据量趋于无限, 学习器会保证输出正确的分类器. 但是应当清楚的一点是: 机器学习的理论保证不应当作为实践决策时的原则, 而仅仅是驱动算法设计的一种理解.

## 7. 特征工程是机器学习的关键

一般来说要分类的原始数据都是比较复杂的, 因此不会那么容易(amenable)学习. 这就需要对数据进行预处理, 提取一些有利于学习的特征, 而如何提取这些特征就不那么显然了, 这也是机器学习在不断发展的方向, 因为我们无法直接给出"最好的特征". 过去主流的方法是由**人**设计各种各样的特征(如均值, 方差, 灰度, 纹理等等), 目前比较流行的方法是让模型自己学习需要的特征(如卷积神经网络).

## 8. 更多的数据可能比一个好算法更有效

假设你能够选择出最好的特征, 此时分类器仍然不够准确, 那么你想提高准确率就有两个途径: (1)选择更好的算法(2)增加更多的数据. 大部分机器学习研究者更倾向于前者, 但可能后者是达到目的最快的做法(这段感觉太扯了, 要是能搞到那么多数据, 谁还去做研究). 

更多的数据也会带了额外的问题: 可扩展性. 在通常的计算机科学中, 两个主要的受限资源是(1)时间(2)内存. 而在机器学习中主要受限的资源是训练数据. 但是现在我们处于大数据时代, 数据并不缺, 缺的其实是时间. 我们可以用大量的数据训练出更好更复杂的模型, 但那太耗时了, 这使得人们不得不继续使用那个用小数据集训练出来的分类器. 

## 9. 多试几个模型, 不要在一棵树上吊死

**最好的模型**因任务的不同而异, 因此多尝试不同的模型去寻找更适合的, 而不是始终只调一个模型的参. 模型 ensemble 也是一种不错的选择. Ensemble 方法不应与贝叶斯模型平均(bayes model average, BMA)混淆, BMA 方法可以参考 [离散数据的生成式模型](https://www.jarvis73.cn/2018/09/27/Generative-Models-for-discrete-data/). 

## 10. 简单不一定意味着准确

**Occam 的剃刀**表明若非必要, 勿增实体. 通常来说, 两个训练误差相同的分类器, 较为简单的那个在测试集上的误差较小. 但实际上这并不总是正确, 否则就不会有 ensemble 的模型被使用了. 

与直觉相矛盾的是, 参数数量和过拟合的趋势没有必然的联系. 仅有一个参数的函数也能判别任意大的数据集, 像 SVM 这样有无穷多参数的模型也能够表现得很好而不过拟合. 

## 11. 可表示不意味着可学习

比如神经网络模型被证明可以表示任意函数, 但是函数可以被表示并不意味着能被学习/训练出来. 比如标准的决策树算法不能学出一个叶子数超过数据量的模型, 比如如果一个函数有非常多的局部极小值, 那么学习算法将很难找到最优解. 所以关键问题并不是"它可以被表示吗?", 而是"它可以被学习吗?"

## 12. 关系不意味着因果

关系可能意味着潜在的因果, 但不能因为关系推导出因果.

## Reference

1. [Stackexchange: How is naive bayes a linear classifier](https://stats.stackexchange.com/questions/142215/how-is-naive-bayes-a-linear-classifier)